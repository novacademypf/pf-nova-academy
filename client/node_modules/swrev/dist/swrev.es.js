var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class DefaultSWREventManager {
  constructor() {
    __publicField(this, "listeners", /* @__PURE__ */ new Map());
  }
  subscribe(key, listener) {
    if (!this.listeners.has(key))
      this.listeners.set(key, []);
    if (this.listeners.get(key).includes(listener))
      return;
    this.listeners.get(key).push(listener);
  }
  unsubscribe(key, listener) {
    if (!this.listeners.has(key))
      return;
    if (!this.listeners.get(key).includes(listener))
      return;
    this.listeners.get(key).splice(this.listeners.get(key).indexOf(listener), 1);
    if (this.listeners.get(key).length === 0)
      this.listeners.delete(key);
  }
  emit(key, payload) {
    if (!this.listeners.has(key))
      return;
    this.listeners.get(key).forEach((listener) => listener(payload));
  }
}
const defaultCacheRemoveOptions = {
  broadcast: false
};
const defaultCacheClearOptions = {
  broadcast: false
};
class CacheItem {
  constructor({ data, expiresAt = null }) {
    __publicField(this, "data");
    __publicField(this, "expiresAt");
    this.data = data;
    this.expiresAt = expiresAt;
  }
  isResolving() {
    return this.data instanceof Promise;
  }
  hasExpired() {
    return this.expiresAt === null || this.expiresAt < new Date();
  }
  expiresIn(milliseconds) {
    this.expiresAt = new Date();
    this.expiresAt.setMilliseconds(this.expiresAt.getMilliseconds() + milliseconds);
    return this;
  }
}
class DefaultCache {
  constructor() {
    __publicField(this, "elements", /* @__PURE__ */ new Map());
    __publicField(this, "event", new DefaultSWREventManager());
  }
  resolve(key, value) {
    Promise.resolve(value.data).then((detail) => {
      if (detail === void 0 || detail === null) {
        return this.remove(key);
      }
      value.data = detail;
      this.broadcast(key, detail);
    });
  }
  get(key) {
    return this.elements.get(key);
  }
  set(key, value) {
    this.elements.set(key, value);
    this.resolve(key, value);
  }
  remove(key, options) {
    const { broadcast } = __spreadValues(__spreadValues({}, defaultCacheRemoveOptions), options);
    if (broadcast)
      this.broadcast(key, void 0);
    this.elements.delete(key);
  }
  clear(options) {
    const { broadcast } = __spreadValues(__spreadValues({}, defaultCacheClearOptions), options);
    if (broadcast)
      for (const key of this.elements.keys())
        this.broadcast(key, void 0);
    this.elements.clear();
  }
  has(key) {
    return this.elements.has(key);
  }
  subscribe(key, listener) {
    this.event.subscribe(key, listener);
  }
  unsubscribe(key, listener) {
    this.event.unsubscribe(key, listener);
  }
  broadcast(key, data) {
    this.event.emit(key, data);
  }
}
const defaultOptions = {
  cache: new DefaultCache(),
  errors: new DefaultSWREventManager(),
  fetcher: async (url) => {
    const response = await fetch(url);
    if (!response.ok)
      throw Error("Not a 2XX response.");
    return response.json();
  },
  initialData: void 0,
  loadInitialCache: true,
  revalidateOnStart: true,
  dedupingInterval: 2e3,
  revalidateOnFocus: true,
  focusThrottleInterval: 5e3,
  revalidateOnReconnect: true,
  reconnectWhen: (notify, { enabled }) => {
    if (enabled && typeof window !== "undefined") {
      window.addEventListener("online", notify);
      return () => window.removeEventListener("online", notify);
    }
    return () => {
    };
  },
  focusWhen: (notify, { enabled, throttleInterval }) => {
    if (enabled && typeof window !== "undefined") {
      let lastFocus = null;
      const rawHandler = () => {
        const now = Date.now();
        if (lastFocus === null || now - lastFocus > throttleInterval) {
          lastFocus = now;
          notify();
        }
      };
      window.addEventListener("focus", rawHandler);
      return () => window.removeEventListener("focus", rawHandler);
    }
    return () => {
    };
  }
};
const defaultRevalidateOptions = __spreadProps(__spreadValues({}, defaultOptions), {
  force: false
});
const defaultMutateOptions = {
  revalidate: true,
  revalidateOptions: __spreadValues({}, defaultRevalidateOptions)
};
const defaultClearOptions = {
  broadcast: false
};
class SWR {
  constructor(options) {
    __publicField(this, "options");
    this.options = __spreadValues(__spreadValues({}, defaultOptions), options);
  }
  get cache() {
    return this.options.cache;
  }
  get errors() {
    return this.options.errors;
  }
  requestData(key, fetcher) {
    return Promise.resolve(fetcher(key)).catch((data) => {
      this.errors.emit(key, data);
      return void 0;
    });
  }
  resolveKey(key) {
    if (typeof key === "function") {
      try {
        return key();
      } catch {
        return void 0;
      }
    }
    return key;
  }
  clear(keys, options) {
    const ops = __spreadValues(__spreadValues({}, defaultClearOptions), options);
    if (keys === void 0 || keys === null)
      return this.cache.clear(ops);
    if (!Array.isArray(keys))
      return this.cache.remove(keys, ops);
    for (const key of keys)
      this.cache.remove(key, ops);
  }
  revalidate(key, options) {
    if (!key)
      return;
    const { fetcher: defaultFetcher, dedupingInterval: defaultDedupingInterval } = this.options;
    const { force, fetcher, dedupingInterval } = __spreadValues(__spreadValues(__spreadValues({}, defaultRevalidateOptions), { fetcher: defaultFetcher, dedupingInterval: defaultDedupingInterval }), options);
    let data = void 0;
    if (force || !this.cache.has(key) || this.cache.has(key) && this.cache.get(key).hasExpired()) {
      data = this.requestData(key, fetcher);
    }
    if (data !== void 0) {
      this.mutate(key, new CacheItem({ data }).expiresIn(dedupingInterval), {
        revalidate: false
      });
    }
  }
  mutate(key, value, options) {
    if (!key)
      return;
    const { revalidate: revalidateAfterMutation, revalidateOptions } = __spreadValues(__spreadValues({}, defaultMutateOptions), options);
    let data;
    if (typeof value === "function") {
      let state = null;
      if (this.cache.has(key)) {
        const item = this.cache.get(key);
        if (!item.isResolving())
          state = item.data;
      }
      data = value(state);
    } else {
      data = value;
    }
    this.cache.set(key, data instanceof CacheItem ? data : new CacheItem({ data }));
    if (revalidateAfterMutation)
      this.revalidate(key, revalidateOptions);
  }
  subscribeData(key, onData) {
    if (key) {
      const handler = (payload) => onData(payload);
      this.cache.subscribe(key, handler);
      return () => this.cache.unsubscribe(key, handler);
    }
    return () => {
    };
  }
  subscribeErrors(key, onError) {
    if (key) {
      const handler = (payload) => onError(payload);
      this.errors.subscribe(key, handler);
      return () => this.errors.unsubscribe(key, handler);
    }
    return () => {
    };
  }
  get(key) {
    if (key && this.cache.has(key)) {
      const item = this.cache.get(key);
      if (!item.isResolving())
        return item.data;
    }
    return void 0;
  }
  getWait(key) {
    return new Promise((resolve, reject) => {
      const unsubscribe = this.subscribeData(key, (data) => {
        unsubscribe();
        return resolve(data);
      });
      const unsubscribeErrors = this.subscribeErrors(key, (error) => {
        unsubscribeErrors();
        return reject(error);
      });
      const current = this.get(key);
      if (current)
        return resolve(current);
    });
  }
  subscribe(key, onData, onError, options) {
    const {
      fetcher,
      initialData,
      loadInitialCache,
      revalidateOnStart,
      dedupingInterval,
      revalidateOnFocus,
      focusThrottleInterval,
      revalidateOnReconnect,
      reconnectWhen,
      focusWhen
    } = __spreadValues(__spreadValues({}, this.options), options);
    const mutateCurrent = (value, options2) => {
      return this.mutate(this.resolveKey(key), value, options2);
    };
    const revalidateCurrent = (options2) => {
      return this.revalidate(this.resolveKey(key), options2);
    };
    const revalidateCurrentWithOptions = () => {
      return revalidateCurrent({ fetcher, dedupingInterval });
    };
    if (revalidateOnStart)
      revalidateCurrentWithOptions();
    const unsubscribeData = this.subscribeData(this.resolveKey(key), onData);
    const unsubscribeErrors = this.subscribeErrors(this.resolveKey(key), onError);
    const unsubscribeVisibility = focusWhen(revalidateCurrentWithOptions, {
      throttleInterval: focusThrottleInterval,
      enabled: revalidateOnFocus
    });
    const unsubscribeNetwork = reconnectWhen(revalidateCurrentWithOptions, {
      enabled: revalidateOnReconnect
    });
    const unsubscribe = () => {
      unsubscribeData();
      unsubscribeErrors();
      unsubscribeVisibility == null ? void 0 : unsubscribeVisibility();
      unsubscribeNetwork == null ? void 0 : unsubscribeNetwork();
    };
    if (initialData) {
      mutateCurrent(initialData, { revalidate: false });
    }
    if (loadInitialCache) {
      const cachedData = this.get(this.resolveKey(key));
      if (cachedData)
        onData(cachedData);
    }
    return { unsubscribe };
  }
}
export { CacheItem, DefaultCache, DefaultSWREventManager, SWR, defaultCacheClearOptions, defaultCacheRemoveOptions, defaultClearOptions, defaultMutateOptions, defaultOptions, defaultRevalidateOptions };
