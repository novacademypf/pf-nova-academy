import { SWR as R } from "swrev";
import { beforeUpdate as _, onDestroy as D } from "svelte";
function h() {
}
function E(t) {
  return t();
}
function q(t) {
  t.forEach(E);
}
function w(t) {
  return typeof t == "function";
}
function K(t, e) {
  return t != t ? e == e : t !== e || t && typeof t == "object" || typeof t == "function";
}
function x(t, ...e) {
  if (t == null)
    return h;
  const n = t.subscribe(...e);
  return n.unsubscribe ? () => n.unsubscribe() : n;
}
Promise.resolve();
const v = [];
function z(t, e) {
  return {
    subscribe: m(t, e).subscribe
  };
}
function m(t, e = h) {
  let n;
  const r = /* @__PURE__ */ new Set();
  function c(i) {
    if (K(t, i) && (t = i, n)) {
      const f = !v.length;
      for (const s of r)
        s[1](), v.push(s, t);
      if (f) {
        for (let s = 0; s < v.length; s += 2)
          v[s][0](v[s + 1]);
        v.length = 0;
      }
    }
  }
  function l(i) {
    c(i(t));
  }
  function d(i, f = h) {
    const s = [i, f];
    return r.add(s), r.size === 1 && (n = e(c) || h), i(t), () => {
      r.delete(s), r.size === 0 && (n(), n = null);
    };
  }
  return { set: c, update: l, subscribe: d };
}
function S(t, e, n) {
  const r = !Array.isArray(t), c = r ? [t] : t, l = e.length < 2;
  return z(n, (d) => {
    let i = !1;
    const f = [];
    let s = 0, p = h;
    const o = () => {
      if (s)
        return;
      p();
      const a = e(r ? f[0] : f, d);
      l ? d(a) : p = w(a) ? a : h;
    }, b = c.map((a, g) => x(a, (y) => {
      f[g] = y, s &= ~(1 << g), i && o();
    }, () => {
      s |= 1 << g;
    }));
    return i = !0, o(), function() {
      q(b), p();
    };
  });
}
class A extends R {
  /**
   * Svelte specific use of SWR.
   */
  useSWR(e, n) {
    let r;
    const c = m(void 0, () => () => r == null ? void 0 : r()), l = m(void 0, () => () => r == null ? void 0 : r());
    _(() => {
      const o = (a) => {
        l.set(void 0), c.set(a);
      }, b = (a) => l.set(a);
      r || (r = this.subscribe(e, o, b, {
        loadInitialCache: !0,
        ...n
      }).unsubscribe);
    }), D(() => r == null ? void 0 : r());
    const d = (o, b) => this.mutate(this.resolveKey(e), o, {
      revalidateOptions: n,
      ...b
    }), i = (o) => this.revalidate(this.resolveKey(e), { ...n, ...o }), f = (o) => this.clear(this.resolveKey(e), o), s = S([c, l], ([o, b]) => o === void 0 && b === void 0), p = S([c, l], ([o, b]) => o !== void 0 && b === void 0);
    return { data: c, error: l, mutate: d, revalidate: i, clear: f, isLoading: s, isValid: p };
  }
}
const W = (t) => new A(t);
let u = W();
const C = (t) => (u = W(t), u), I = (t, e) => u.subscribeData(t, e), L = (t, e) => u.subscribeErrors(t, e), P = (t) => u.get(t), U = (t) => u.getWait(t), V = (t, e, n, r) => u.subscribe(t, e, n, r), $ = (t, e) => u.useSWR(t, e), B = (t, e, n) => u.mutate(t, e, n), F = (t, e) => u.revalidate(t, e), G = (t, e) => u.clear(t, e);
export {
  A as SSWR,
  G as clear,
  C as createDefaultSWR,
  W as createSWR,
  P as get,
  U as getOrWait,
  B as mutate,
  F as revalidate,
  I as subscribe,
  L as subscribeErrors,
  u as swr,
  V as use,
  $ as useSWR
};
